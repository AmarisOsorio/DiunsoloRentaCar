/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#pragma once

#include <react/bridging/Base.h>

namespace facebook::react::bridging {

template <
<<<<<<< HEAD
    typename JSReturnT,
    typename ClassT,
    typename ReturnT,
    typename... ArgsT,
    typename... JSArgsT>
JSReturnT callFromJs(
    jsi::Runtime& rt,
    ReturnT (ClassT::*method)(jsi::Runtime&, ArgsT...),
    const std::shared_ptr<CallInvoker>& jsInvoker,
    ClassT* instance,
    JSArgsT&&... args) {
  static_assert(
      sizeof...(ArgsT) == sizeof...(JSArgsT), "Incorrect arguments length");
  static_assert(
      (supportsFromJs<ArgsT, JSArgsT> && ...), "Incompatible arguments");

  if constexpr (std::is_void_v<JSReturnT>) {
    (instance->*method)(
        rt, fromJs<ArgsT>(rt, std::forward<JSArgsT>(args), jsInvoker)...);

  } else if constexpr (std::is_void_v<ReturnT>) {
    static_assert(
        std::is_same_v<JSReturnT, jsi::Value>,
        "Void functions may only return undefined");

    (instance->*method)(
        rt, fromJs<ArgsT>(rt, std::forward<JSArgsT>(args), jsInvoker)...);
    return jsi::Value();

  } else if constexpr (
      is_jsi_v<JSReturnT> || supportsToJs<ReturnT, JSReturnT>) {
    static_assert(supportsToJs<ReturnT, JSReturnT>, "Incompatible return type");
=======
    typename T,
    typename C,
    typename R,
    typename... Args,
    typename... JSArgs>
T callFromJs(
    jsi::Runtime& rt,
    R (C::*method)(jsi::Runtime&, Args...),
    const std::shared_ptr<CallInvoker>& jsInvoker,
    C* instance,
    JSArgs&&... args) {
  static_assert(
      sizeof...(Args) == sizeof...(JSArgs), "Incorrect arguments length");
  static_assert(
      (supportsFromJs<Args, JSArgs> && ...), "Incompatible arguments");

  if constexpr (std::is_void_v<T>) {
    (instance->*method)(
        rt, fromJs<Args>(rt, std::forward<JSArgs>(args), jsInvoker)...);

  } else if constexpr (std::is_void_v<R>) {
    static_assert(
        std::is_same_v<T, jsi::Value>,
        "Void functions may only return undefined");

    (instance->*method)(
        rt, fromJs<Args>(rt, std::forward<JSArgs>(args), jsInvoker)...);
    return jsi::Value();

  } else if constexpr (is_jsi_v<T>) {
    static_assert(supportsToJs<R, T>, "Incompatible return type");
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767

    return toJs(
        rt,
        (instance->*method)(
<<<<<<< HEAD
            rt, fromJs<ArgsT>(rt, std::forward<JSArgsT>(args), jsInvoker)...),
        jsInvoker);
  } else if constexpr (is_optional_jsi_v<JSReturnT>) {
    static_assert(
        is_optional_v<ReturnT>
            ? supportsToJs<
                  typename ReturnT::value_type,
                  typename JSReturnT::value_type>
            : supportsToJs<ReturnT, typename JSReturnT::value_type>,
=======
            rt, fromJs<Args>(rt, std::forward<JSArgs>(args), jsInvoker)...),
        jsInvoker);

  } else if constexpr (is_optional_jsi_v<T>) {
    static_assert(
        is_optional_v<R>
            ? supportsToJs<typename R::value_type, typename T::value_type>
            : supportsToJs<R, typename T::value_type>,
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
        "Incompatible return type");

    auto result = toJs(
        rt,
        (instance->*method)(
<<<<<<< HEAD
            rt, fromJs<ArgsT>(rt, std::forward<JSArgsT>(args), jsInvoker)...),
=======
            rt, fromJs<Args>(rt, std::forward<JSArgs>(args), jsInvoker)...),
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
        jsInvoker);

    if constexpr (std::is_same_v<decltype(result), jsi::Value>) {
      if (result.isNull() || result.isUndefined()) {
        return std::nullopt;
      }
    }

    return convert(rt, std::move(result));
  } else {
<<<<<<< HEAD
    static_assert(
        std::is_convertible_v<ReturnT, JSReturnT>, "Incompatible return type");
    return (instance->*method)(
        rt, fromJs<ArgsT>(rt, std::forward<JSArgsT>(args), jsInvoker)...);
  }
}

template <typename ReturnT, typename... ArgsT>
constexpr size_t getParameterCount(ReturnT (*)(ArgsT...)) {
  return sizeof...(ArgsT);
}

template <typename Class, typename ReturnT, typename... ArgsT>
constexpr size_t getParameterCount(ReturnT (Class::*)(ArgsT...)) {
  return sizeof...(ArgsT);
=======
    static_assert(std::is_convertible_v<R, T>, "Incompatible return type");
    return (instance->*method)(
        rt, fromJs<Args>(rt, std::forward<JSArgs>(args), jsInvoker)...);
  }
}

template <typename R, typename... Args>
constexpr size_t getParameterCount(R (*)(Args...)) {
  return sizeof...(Args);
}

template <typename C, typename R, typename... Args>
constexpr size_t getParameterCount(R (C::*)(Args...)) {
  return sizeof...(Args);
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
}

} // namespace facebook::react::bridging
