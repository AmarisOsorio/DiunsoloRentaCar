/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#pragma once

#include <react/timing/primitives.h>
<<<<<<< HEAD

#include <optional>
#include <string>
#include <variant>
=======
#include <optional>
#include <string>
#include <unordered_set>
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767

namespace facebook::react {

using PerformanceEntryInteractionId = uint32_t;

enum class PerformanceEntryType {
  // We need to preserve these values for backwards compatibility.
  MARK = 1,
  MEASURE = 2,
  EVENT = 3,
  LONGTASK = 4,
<<<<<<< HEAD
  RESOURCE = 5,
  _NEXT = 6,
};

struct AbstractPerformanceEntry {
  std::string name;
  HighResTimeStamp startTime;
  HighResDuration duration = HighResDuration::zero();
};

struct PerformanceMark : AbstractPerformanceEntry {
  static constexpr PerformanceEntryType entryType = PerformanceEntryType::MARK;
};

struct PerformanceMeasure : AbstractPerformanceEntry {
  static constexpr PerformanceEntryType entryType =
      PerformanceEntryType::MEASURE;
};

struct PerformanceEventTiming : AbstractPerformanceEntry {
  static constexpr PerformanceEntryType entryType = PerformanceEntryType::EVENT;
  HighResTimeStamp processingStart;
  HighResTimeStamp processingEnd;
  PerformanceEntryInteractionId interactionId;
};

struct PerformanceLongTaskTiming : AbstractPerformanceEntry {
  static constexpr PerformanceEntryType entryType =
      PerformanceEntryType::LONGTASK;
};

struct PerformanceResourceTiming : AbstractPerformanceEntry {
  static constexpr PerformanceEntryType entryType =
      PerformanceEntryType::RESOURCE;
  /** Aligns with `startTime`. */
  HighResTimeStamp fetchStart;
  HighResTimeStamp requestStart;
  std::optional<HighResTimeStamp> connectStart;
  std::optional<HighResTimeStamp> connectEnd;
  std::optional<HighResTimeStamp> responseStart;
  /** Aligns with `duration`. */
  std::optional<HighResTimeStamp> responseEnd;
  std::optional<int> responseStatus;
};

using PerformanceEntry = std::variant<
    PerformanceMark,
    PerformanceMeasure,
    PerformanceEventTiming,
    PerformanceLongTaskTiming,
    PerformanceResourceTiming>;

struct PerformanceEntrySorter {
  bool operator()(const PerformanceEntry& lhs, const PerformanceEntry& rhs) {
    return std::visit(
        [](const auto& left, const auto& right) {
          if (left.startTime != right.startTime) {
            return left.startTime < right.startTime;
          }
          return left.duration < right.duration;
        },
        lhs,
        rhs);
=======
  _NEXT = 5,
};

struct PerformanceEntry {
  std::string name;
  PerformanceEntryType entryType;
  DOMHighResTimeStamp startTime;
  DOMHighResTimeStamp duration = 0;

  // For "event" entries only:
  std::optional<DOMHighResTimeStamp> processingStart;
  std::optional<DOMHighResTimeStamp> processingEnd;
  std::optional<PerformanceEntryInteractionId> interactionId;
};

constexpr size_t NUM_PERFORMANCE_ENTRY_TYPES =
    (size_t)PerformanceEntryType::_NEXT - 1; // Valid types start from 1.

struct PerformanceEntrySorter {
  bool operator()(const PerformanceEntry& lhs, const PerformanceEntry& rhs) {
    if (lhs.startTime != rhs.startTime) {
      return lhs.startTime < rhs.startTime;
    } else {
      return lhs.duration < rhs.duration;
    }
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
  }
};

} // namespace facebook::react
