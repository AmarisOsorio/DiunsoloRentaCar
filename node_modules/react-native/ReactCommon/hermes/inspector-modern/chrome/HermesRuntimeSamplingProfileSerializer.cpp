/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

<<<<<<< HEAD
#include <variant>

=======
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
#include "HermesRuntimeSamplingProfileSerializer.h"

namespace facebook::react::jsinspector_modern::tracing {

namespace {

<<<<<<< HEAD
namespace fhsp = facebook::hermes::sampling_profiler;

/// Fallback script ID for call frames, when Hermes didn't provide one or when
/// this frame is part of the VM, like native functions, used for parity with
/// Chromium + V8.
constexpr uint32_t FALLBACK_SCRIPT_ID = 0;
/// Garbage collector frame name, used for parity with Chromium + V8.
constexpr std::string_view GARBAGE_COLLECTOR_FRAME_NAME = "(garbage collector)";
=======
/// Fallback script ID for call frames, when Hermes didn't provide one or when
/// this frame is part of the VM, like native functions, used for parity with
/// Chromium + V8.
const uint32_t FALLBACK_SCRIPT_ID = 0;
/// Garbage collector frame name, used for parity with Chromium + V8.
const std::string GARBAGE_COLLECTOR_FRAME_NAME = "(garbage collector)";
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767

/// Filters out Hermes Suspend frames related to Debugger.
/// Even though Debugger domain is expected to be disabled, Hermes might run
/// Debugger loop while recording sampling profile. We only allow GC frames.
<<<<<<< HEAD
inline bool shouldIgnoreHermesFrame(
    const fhsp::ProfileSampleCallStackSuspendFrame& suspendFrame) {
  return suspendFrame.getSuspendFrameKind() !=
      fhsp::ProfileSampleCallStackSuspendFrame::SuspendFrameKind::GC;
}

RuntimeSamplingProfile::SampleCallStackFrame convertNativeHermesFrame(
    const fhsp::ProfileSampleCallStackNativeFunctionFrame& frame) {
  return RuntimeSamplingProfile::SampleCallStackFrame{
      RuntimeSamplingProfile::SampleCallStackFrame::Kind::NativeFunction,
      FALLBACK_SCRIPT_ID, // JavaScript Runtime defines the implementation
                          // for native function, no script ID to reference.
      frame.getFunctionName(),
  };
}

RuntimeSamplingProfile::SampleCallStackFrame convertHostFunctionHermesFrame(
    const fhsp::ProfileSampleCallStackHostFunctionFrame& frame) {
  return RuntimeSamplingProfile::SampleCallStackFrame{
      RuntimeSamplingProfile::SampleCallStackFrame::Kind::HostFunction,
      FALLBACK_SCRIPT_ID, // JavaScript Runtime defines the implementation
                          // for host function, no script ID to reference.
      frame.getFunctionName(),
  };
}

RuntimeSamplingProfile::SampleCallStackFrame convertSuspendHermesFrame(
    const fhsp::ProfileSampleCallStackSuspendFrame& frame) {
  if (frame.getSuspendFrameKind() ==
      fhsp::ProfileSampleCallStackSuspendFrame::SuspendFrameKind::GC) {
    return RuntimeSamplingProfile::SampleCallStackFrame{
        RuntimeSamplingProfile::SampleCallStackFrame::Kind::GarbageCollector,
        FALLBACK_SCRIPT_ID, // GC frames are part of the VM, no script ID to
                            // reference.
        GARBAGE_COLLECTOR_FRAME_NAME,
    };
  }

  // We should have filtered out Debugger Suspend frames before in
  // shouldFilterOutHermesFrame().
  throw std::logic_error{"Unexpected Suspend frame found in Hermes call stack"};
}

RuntimeSamplingProfile::SampleCallStackFrame convertJSFunctionHermesFrame(
    const fhsp::ProfileSampleCallStackJSFunctionFrame& frame) {
  return RuntimeSamplingProfile::SampleCallStackFrame{
      RuntimeSamplingProfile::SampleCallStackFrame::Kind::JSFunction,
      frame.getScriptId(),
      frame.getFunctionName(),
      frame.hasScriptUrl()
          ? std::optional<std::string_view>{frame.getScriptUrl()}
          : std::nullopt,
      frame.hasFunctionLineNumber()
          ? std::optional<uint32_t>{frame.getFunctionLineNumber() - 1}
          // Hermes VM keeps line numbers as 1-based. Convert
          // to 0-based.
          : std::nullopt,
      frame.hasFunctionColumnNumber()
          ? std::optional<uint32_t>{frame.getFunctionColumnNumber() - 1}
          // Hermes VM keeps column numbers as 1-based. Convert to
          // 0-based.
          : std::nullopt,
  };
}

RuntimeSamplingProfile::Sample convertHermesSampleToTracingSample(
    const fhsp::ProfileSample& hermesSample) {
  uint64_t reconciledTimestamp = hermesSample.getTimestamp();
  const auto callStackRange = hermesSample.getCallStackFramesRange();

  std::vector<RuntimeSamplingProfile::SampleCallStackFrame>
      reconciledSampleCallStack;
  reconciledSampleCallStack.reserve(hermesSample.getCallStackFramesCount());

  for (const auto& hermesFrame : callStackRange) {
    if (std::holds_alternative<fhsp::ProfileSampleCallStackSuspendFrame>(
            hermesFrame)) {
      const auto& suspendFrame =
          std::get<fhsp::ProfileSampleCallStackSuspendFrame>(hermesFrame);
      if (shouldIgnoreHermesFrame(suspendFrame)) {
        continue;
      }

      reconciledSampleCallStack.emplace_back(
          convertSuspendHermesFrame(suspendFrame));
    } else if (std::holds_alternative<
                   fhsp::ProfileSampleCallStackNativeFunctionFrame>(
                   hermesFrame)) {
      const auto& nativeFunctionFrame =
          std::get<fhsp::ProfileSampleCallStackNativeFunctionFrame>(
              hermesFrame);
      reconciledSampleCallStack.emplace_back(
          convertNativeHermesFrame(nativeFunctionFrame));
    } else if (std::holds_alternative<
                   fhsp::ProfileSampleCallStackHostFunctionFrame>(
                   hermesFrame)) {
      const auto& hostFunctionFrame =
          std::get<fhsp::ProfileSampleCallStackHostFunctionFrame>(hermesFrame);
      reconciledSampleCallStack.emplace_back(
          convertHostFunctionHermesFrame(hostFunctionFrame));
    } else if (std::holds_alternative<
                   fhsp::ProfileSampleCallStackJSFunctionFrame>(hermesFrame)) {
      const auto& jsFunctionFrame =
          std::get<fhsp::ProfileSampleCallStackJSFunctionFrame>(hermesFrame);
      reconciledSampleCallStack.emplace_back(
          convertJSFunctionHermesFrame(jsFunctionFrame));
    } else {
      throw std::logic_error{"Unknown Hermes stack frame kind"};
    }
=======
bool shouldIgnoreHermesFrame(
    hermes::sampling_profiler::ProfileSampleCallStackFrame* hermesFrame) {
  if (hermesFrame->getKind() !=
      hermes::sampling_profiler::ProfileSampleCallStackFrame::Kind::Suspend) {
    return false;
  }

  auto* suspendFrame = static_cast<
      hermes::sampling_profiler::ProfileSampleCallStackSuspendFrame*>(
      hermesFrame);
  auto suspendFrameKind = suspendFrame->getSuspendFrameKind();
  return suspendFrameKind !=
      hermes::sampling_profiler::ProfileSampleCallStackSuspendFrame::
          SuspendFrameKind::GC;
}

RuntimeSamplingProfile::SampleCallStackFrame convertHermesFrameToTracingFrame(
    hermes::sampling_profiler::ProfileSampleCallStackFrame* hermesFrame) {
  switch (hermesFrame->getKind()) {
    case hermes::sampling_profiler::ProfileSampleCallStackFrame::Kind::
        JSFunction: {
      auto* jsFunctionFrame = static_cast<
          hermes::sampling_profiler::ProfileSampleCallStackJSFunctionFrame*>(
          hermesFrame);
      return RuntimeSamplingProfile::SampleCallStackFrame{
          RuntimeSamplingProfile::SampleCallStackFrame::Kind::JSFunction,
          jsFunctionFrame->hasScriptId() ? jsFunctionFrame->getScriptId()
                                         : FALLBACK_SCRIPT_ID,
          jsFunctionFrame->getFunctionName(),
          jsFunctionFrame->hasUrl()
              ? std::optional<std::string>{jsFunctionFrame->getUrl()}
              : std::nullopt,
          jsFunctionFrame->hasLineNumber()
              ? std::optional<uint32_t>{jsFunctionFrame->getLineNumber() - 1}
              // Hermes VM keeps line numbers as 1-based. Convert to
              // 0-based.
              : std::nullopt,
          jsFunctionFrame->hasColumnNumber()
              ? std::optional<uint32_t>{jsFunctionFrame->getColumnNumber() - 1}
              // Hermes VM keeps column numbers as 1-based. Convert to
              // 0-based.
              : std::nullopt,
      };
    }
    case hermes::sampling_profiler::ProfileSampleCallStackFrame::Kind::
        NativeFunction: {
      auto* nativeFunctionFrame =
          static_cast<hermes::sampling_profiler::
                          ProfileSampleCallStackNativeFunctionFrame*>(
              hermesFrame);

      return RuntimeSamplingProfile::SampleCallStackFrame{
          RuntimeSamplingProfile::SampleCallStackFrame::Kind::NativeFunction,
          FALLBACK_SCRIPT_ID, // JavaScript Runtime defines the implementation
                              // for native function, no script ID to reference.
          nativeFunctionFrame->getFunctionName(),
      };
    }
    case hermes::sampling_profiler::ProfileSampleCallStackFrame::Kind::
        HostFunction: {
      auto* hostFunctionFrame = static_cast<
          hermes::sampling_profiler::ProfileSampleCallStackHostFunctionFrame*>(
          hermesFrame);

      return RuntimeSamplingProfile::SampleCallStackFrame{
          RuntimeSamplingProfile::SampleCallStackFrame::Kind::HostFunction,
          FALLBACK_SCRIPT_ID, // JavaScript Runtime defines the implementation
                              // for host function, no script ID to reference.
          hostFunctionFrame->getFunctionName(),
      };
    }
    case hermes::sampling_profiler::ProfileSampleCallStackFrame::Kind::
        Suspend: {
      auto* suspendFrame = static_cast<
          hermes::sampling_profiler::ProfileSampleCallStackSuspendFrame*>(
          hermesFrame);
      auto suspendFrameKind = suspendFrame->getSuspendFrameKind();
      if (suspendFrameKind ==
          hermes::sampling_profiler::ProfileSampleCallStackSuspendFrame::
              SuspendFrameKind::GC) {
        return RuntimeSamplingProfile::SampleCallStackFrame{
            RuntimeSamplingProfile::SampleCallStackFrame::Kind::
                GarbageCollector,
            FALLBACK_SCRIPT_ID, // GC frames are part of the VM, no script ID to
                                // reference.
            GARBAGE_COLLECTOR_FRAME_NAME,
        };
      }

      // We should have filtered out Debugger Suspend frames before in
      // shouldFilterOutHermesFrame().
      throw std::logic_error{
          "Unexpected Suspend frame found in Hermes call stack"};
    }

    default:
      throw std::logic_error{"Unknown Hermes stack frame kind"};
  }
}

RuntimeSamplingProfile::Sample convertHermesSampleToTracingSample(
    hermes::sampling_profiler::ProfileSample& hermesSample) {
  uint64_t reconciledTimestamp = hermesSample.getTimestamp();
  std::vector<hermes::sampling_profiler::ProfileSampleCallStackFrame*>
      hermesSampleCallStack = hermesSample.getCallStack();

  std::vector<RuntimeSamplingProfile::SampleCallStackFrame>
      reconciledSampleCallStack;
  reconciledSampleCallStack.reserve(hermesSampleCallStack.size());

  for (auto* hermesFrame : hermesSampleCallStack) {
    if (shouldIgnoreHermesFrame(hermesFrame)) {
      continue;
    }
    RuntimeSamplingProfile::SampleCallStackFrame reconciledFrame =
        convertHermesFrameToTracingFrame(hermesFrame);
    reconciledSampleCallStack.push_back(std::move(reconciledFrame));
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
  }

  return RuntimeSamplingProfile::Sample{
      reconciledTimestamp,
      hermesSample.getThreadId(),
      std::move(reconciledSampleCallStack)};
}

} // namespace

/* static */ RuntimeSamplingProfile
HermesRuntimeSamplingProfileSerializer::serializeToTracingSamplingProfile(
<<<<<<< HEAD
    hermes::sampling_profiler::Profile hermesProfile) {
  const auto samplesRange = hermesProfile.getSamplesRange();
  std::vector<RuntimeSamplingProfile::Sample> reconciledSamples;
  reconciledSamples.reserve(hermesProfile.getSamplesCount());

  for (const auto& hermesSample : samplesRange) {
=======
    const hermes::sampling_profiler::Profile& hermesProfile) {
  std::vector<hermes::sampling_profiler::ProfileSample> hermesSamples =
      hermesProfile.getSamples();
  std::vector<RuntimeSamplingProfile::Sample> reconciledSamples;
  reconciledSamples.reserve(hermesSamples.size());

  for (auto& hermesSample : hermesSamples) {
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
    RuntimeSamplingProfile::Sample reconciledSample =
        convertHermesSampleToTracingSample(hermesSample);
    reconciledSamples.push_back(std::move(reconciledSample));
  }

<<<<<<< HEAD
  return RuntimeSamplingProfile{
      "Hermes",
      std::move(reconciledSamples),
      std::make_unique<RawHermesRuntimeProfile>(std::move(hermesProfile))};
=======
  return RuntimeSamplingProfile{"Hermes", std::move(reconciledSamples)};
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
}

} // namespace facebook::react::jsinspector_modern::tracing
