/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

<<<<<<< HEAD
#include <string_view>

#include "ProfileTreeNode.h"
#include "RuntimeSamplingProfileTraceEventSerializer.h"
=======
#include "RuntimeSamplingProfileTraceEventSerializer.h"
#include "ProfileTreeNode.h"
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767

namespace facebook::react::jsinspector_modern::tracing {

namespace {

<<<<<<< HEAD
// To capture samples timestamps Hermes is using steady_clock and returns
// them in microseconds granularity since epoch. In the future we might want to
// update Hermes to return timestamps in chrono type.
HighResTimeStamp getHighResTimeStampForSample(
    const RuntimeSamplingProfile::Sample& sample) {
  auto microsecondsSinceSteadyClockEpoch = sample.getTimestamp();
  auto chronoTimePoint = std::chrono::steady_clock::time_point(
      std::chrono::microseconds(microsecondsSinceSteadyClockEpoch));
  return HighResTimeStamp::fromChronoSteadyClockTimePoint(chronoTimePoint);
}

// Right now we only emit single Profile. We might revisit this decision in the
// future, once we support multiple VMs being sampled at the same time.
constexpr uint16_t PROFILE_ID = 1;

/// Fallback script ID for artificial call frames, such as (root), (idle) or
/// (program). Required for emulating the payload in a format that is expected
/// by Chrome DevTools.
constexpr uint32_t FALLBACK_SCRIPT_ID = 0;

constexpr std::string_view GARBAGE_COLLECTOR_FRAME_NAME = "(garbage collector)";
constexpr std::string_view ROOT_FRAME_NAME = "(root)";
constexpr std::string_view IDLE_FRAME_NAME = "(idle)";
constexpr std::string_view PROGRAM_FRAME_NAME = "(program)";

TraceEventProfileChunk::CPUProfile::Node convertToTraceEventProfileNode(
    const ProfileTreeNode& node) {
  const RuntimeSamplingProfile::SampleCallStackFrame& callFrame =
      node.getCallFrame();
  auto traceEventCallFrame =
      TraceEventProfileChunk::CPUProfile::Node::CallFrame{
          node.getCodeType() == ProfileTreeNode::CodeType::JavaScript ? "JS"
                                                                      : "other",
          callFrame.getScriptId(),
          std::string(callFrame.getFunctionName()),
          callFrame.hasUrl()
              ? std::optional<std::string>(std::string(callFrame.getUrl()))
              : std::nullopt,
=======
uint64_t formatTimePointToUnixTimestamp(
    std::chrono::steady_clock::time_point timestamp) {
  return std::chrono::duration_cast<std::chrono::microseconds>(
             timestamp.time_since_epoch())
      .count();
}

TraceEventProfileChunk::CPUProfile::Node convertToTraceEventProfileNode(
    ProfileTreeNode* node) {
  ProfileTreeNode* nodeParent = node->getParent();
  const RuntimeSamplingProfile::SampleCallStackFrame& callFrame =
      node->getCallFrame();
  auto traceEventCallFrame =
      TraceEventProfileChunk::CPUProfile::Node::CallFrame{
          node->getCodeType() == ProfileTreeNode::CodeType::JavaScript
              ? "JS"
              : "other",
          callFrame.getScriptId(),
          callFrame.getFunctionName(),
          callFrame.hasUrl() ? std::optional<std::string>(callFrame.getUrl())
                             : std::nullopt,
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
          callFrame.hasLineNumber()
              ? std::optional<uint32_t>(callFrame.getLineNumber())
              : std::nullopt,
          callFrame.hasColumnNumber()
              ? std::optional<uint32_t>(callFrame.getColumnNumber())
              : std::nullopt};

  return TraceEventProfileChunk::CPUProfile::Node{
<<<<<<< HEAD
      node.getId(),
      traceEventCallFrame,
      node.hasParent() ? std::optional<uint32_t>(node.getParentId())
                       : std::nullopt};
}

RuntimeSamplingProfile::SampleCallStackFrame createArtificialCallFrame(
    std::string_view callFrameName) {
  return RuntimeSamplingProfile::SampleCallStackFrame{
      RuntimeSamplingProfile::SampleCallStackFrame::Kind::JSFunction,
      FALLBACK_SCRIPT_ID,
      callFrameName};
};

RuntimeSamplingProfile::SampleCallStackFrame createGarbageCollectorCallFrame() {
  return RuntimeSamplingProfile::SampleCallStackFrame{
      RuntimeSamplingProfile::SampleCallStackFrame::Kind::GarbageCollector,
      FALLBACK_SCRIPT_ID,
      GARBAGE_COLLECTOR_FRAME_NAME};
};

class ProfileTreeRootNode : public ProfileTreeNode {
 public:
  explicit ProfileTreeRootNode(uint32_t id)
      : ProfileTreeNode(
            id,
            CodeType::Other,
            createArtificialCallFrame(ROOT_FRAME_NAME)) {}
};

} // namespace

void RuntimeSamplingProfileTraceEventSerializer::sendProfileTraceEvent(
    uint64_t threadId,
    uint16_t profileId,
    HighResTimeStamp profileStartTimestamp) const {
  folly::dynamic serializedTraceEvent =
      performanceTracer_.getSerializedRuntimeProfileTraceEvent(
          threadId, profileId, profileStartTimestamp);

  notificationCallback_(folly::dynamic::array(serializedTraceEvent));
}

void RuntimeSamplingProfileTraceEventSerializer::chunkEmptySample(
    ProfileChunk& chunk,
    uint32_t idleNodeId,
    HighResDuration samplesTimeDelta) {
  chunk.samples.push_back(idleNodeId);
  chunk.timeDeltas.push_back(samplesTimeDelta);
}

void RuntimeSamplingProfileTraceEventSerializer::bufferProfileChunkTraceEvent(
    ProfileChunk& chunk,
    uint16_t profileId) {
  if (chunk.isEmpty()) {
    return;
  }

  std::vector<TraceEventProfileChunk::CPUProfile::Node> traceEventNodes;
  traceEventNodes.reserve(chunk.nodes.size());
  for (const auto& node : chunk.nodes) {
    traceEventNodes.push_back(convertToTraceEventProfileNode(node));
  }

  traceEventBuffer_.push_back(
      performanceTracer_.getSerializedRuntimeProfileChunkTraceEvent(
          profileId,
          chunk.threadId,
          chunk.timestamp,
          TraceEventProfileChunk{
              .cpuProfile =
                  TraceEventProfileChunk::CPUProfile{
                      traceEventNodes, chunk.samples},
              .timeDeltas =
                  TraceEventProfileChunk::TimeDeltas{chunk.timeDeltas},
          }));
}

void RuntimeSamplingProfileTraceEventSerializer::processCallStack(
    const std::vector<RuntimeSamplingProfile::SampleCallStackFrame>& callStack,
    ProfileChunk& chunk,
    ProfileTreeNode& rootNode,
    uint32_t idleNodeId,
    HighResDuration samplesTimeDelta,
    NodeIdGenerator& nodeIdGenerator) {
  if (callStack.empty()) {
    chunkEmptySample(chunk, idleNodeId, samplesTimeDelta);
    return;
  }

  ProfileTreeNode* previousNode = &rootNode;
  for (auto it = callStack.rbegin(); it != callStack.rend(); ++it) {
    const RuntimeSamplingProfile::SampleCallStackFrame& callFrame = *it;
    bool isGarbageCollectorFrame = callFrame.getKind() ==
        RuntimeSamplingProfile::SampleCallStackFrame::Kind::GarbageCollector;

    ProfileTreeNode::CodeType childCodeType = isGarbageCollectorFrame
        ? ProfileTreeNode::CodeType::Other
        : ProfileTreeNode::CodeType::JavaScript;
    // We don't need real garbage collector call frame, we change it to
    // what Chrome DevTools expects.
    RuntimeSamplingProfile::SampleCallStackFrame childCallFrame =
        isGarbageCollectorFrame ? createGarbageCollectorCallFrame() : callFrame;

    ProfileTreeNode* maybeExistingChild =
        previousNode->getIfAlreadyExists(childCodeType, childCallFrame);
    if (maybeExistingChild != nullptr) {
      previousNode = maybeExistingChild;
    } else {
      previousNode = previousNode->addChild(
          nodeIdGenerator.getNext(), childCodeType, childCallFrame);
      chunk.nodes.push_back(*previousNode);
    }
  }

  chunk.samples.push_back(previousNode->getId());
  chunk.timeDeltas.push_back(samplesTimeDelta);
}

void RuntimeSamplingProfileTraceEventSerializer::
    sendBufferedTraceEventsAndClear() {
  notificationCallback_(traceEventBuffer_);
  traceEventBuffer_ = folly::dynamic::array();
}

void RuntimeSamplingProfileTraceEventSerializer::serializeAndNotify(
    const RuntimeSamplingProfile& profile,
    HighResTimeStamp tracingStartTime) {
  const std::vector<RuntimeSamplingProfile::Sample>& samples =
      profile.getSamples();
  if (samples.empty()) {
    return;
  }

  uint64_t firstChunkThreadId = samples.front().getThreadId();
  HighResTimeStamp previousSampleTimestamp = tracingStartTime;
  HighResTimeStamp currentChunkTimestamp = tracingStartTime;

  sendProfileTraceEvent(firstChunkThreadId, PROFILE_ID, tracingStartTime);

  // There could be any number of new nodes in this chunk. Empty if all nodes
  // are already emitted in previous chunks.
  ProfileChunk chunk{
      profileChunkSize_, firstChunkThreadId, currentChunkTimestamp};

  NodeIdGenerator nodeIdGenerator{};

  ProfileTreeRootNode rootNode(nodeIdGenerator.getNext());
  chunk.nodes.push_back(rootNode);

  ProfileTreeNode* programNode = rootNode.addChild(
      nodeIdGenerator.getNext(),
      ProfileTreeNode::CodeType::Other,
      createArtificialCallFrame(PROGRAM_FRAME_NAME));
  chunk.nodes.push_back(*programNode);

  ProfileTreeNode* idleNode = rootNode.addChild(
      nodeIdGenerator.getNext(),
      ProfileTreeNode::CodeType::Other,
      createArtificialCallFrame(IDLE_FRAME_NAME));
  chunk.nodes.push_back(*idleNode);
  uint32_t idleNodeId = idleNode->getId();

  for (const auto& sample : samples) {
    uint64_t currentSampleThreadId = sample.getThreadId();
    auto currentSampleTimestamp = getHighResTimeStampForSample(sample);

    // We should not attempt to merge samples from different threads.
    // From past observations, this only happens for GC nodes.
    // We should group samples by thread id once we support executing JavaScript
    // on different threads.
    if (currentSampleThreadId != chunk.threadId || chunk.isFull()) {
      bufferProfileChunkTraceEvent(chunk, PROFILE_ID);
      chunk = ProfileChunk{
          profileChunkSize_, currentSampleThreadId, currentChunkTimestamp};
    }

    if (traceEventBuffer_.size() == traceEventChunkSize_) {
      sendBufferedTraceEventsAndClear();
    }

    processCallStack(
        sample.getCallStack(),
        chunk,
        rootNode,
        idleNodeId,
        currentSampleTimestamp - previousSampleTimestamp,
        nodeIdGenerator);

    previousSampleTimestamp = currentSampleTimestamp;
  }

  if (!chunk.isEmpty()) {
    bufferProfileChunkTraceEvent(chunk, PROFILE_ID);
  }

  if (!traceEventBuffer_.empty()) {
    sendBufferedTraceEventsAndClear();
=======
      node->getId(),
      traceEventCallFrame,
      nodeParent != nullptr ? std::optional<uint32_t>(nodeParent->getId())
                            : std::nullopt};
}

void emitSingleProfileChunk(
    PerformanceTracer& performanceTracer,
    uint16_t profileId,
    uint64_t threadId,
    uint64_t chunkTimestamp,
    std::vector<ProfileTreeNode*>& nodes,
    std::vector<uint32_t>& samples,
    std::vector<long long>& timeDeltas) {
  std::vector<TraceEventProfileChunk::CPUProfile::Node> traceEventNodes;
  traceEventNodes.reserve(nodes.size());
  for (ProfileTreeNode* node : nodes) {
    traceEventNodes.push_back(convertToTraceEventProfileNode(node));
  }

  performanceTracer.reportRuntimeProfileChunk(
      profileId,
      threadId,
      chunkTimestamp,
      TraceEventProfileChunk{
          TraceEventProfileChunk::CPUProfile{traceEventNodes, samples},
          TraceEventProfileChunk::TimeDeltas{timeDeltas},
      });
}

} // namespace

/* static */ void
RuntimeSamplingProfileTraceEventSerializer::serializeAndBuffer(
    PerformanceTracer& performanceTracer,
    const RuntimeSamplingProfile& profile,
    std::chrono::steady_clock::time_point tracingStartTime,
    uint16_t profileChunkSize) {
  std::vector<RuntimeSamplingProfile::Sample> runtimeSamples =
      profile.getSamples();
  if (runtimeSamples.empty()) {
    return;
  }

  uint64_t chunkThreadId = runtimeSamples.front().getThreadId();
  uint64_t tracingStartUnixTimestamp =
      formatTimePointToUnixTimestamp(tracingStartTime);
  uint16_t profileId = performanceTracer.reportRuntimeProfile(
      chunkThreadId, tracingStartUnixTimestamp);

  uint32_t nodeCount = 0;
  auto* rootNode = new ProfileTreeNode(
      ++nodeCount,
      ProfileTreeNode::CodeType::Other,
      nullptr,
      RuntimeSamplingProfile::SampleCallStackFrame{
          RuntimeSamplingProfile::SampleCallStackFrame::Kind::JSFunction,
          0,
          "(root)"});
  auto* programNode = new ProfileTreeNode(
      ++nodeCount,
      ProfileTreeNode::CodeType::Other,
      rootNode,
      RuntimeSamplingProfile::SampleCallStackFrame{
          RuntimeSamplingProfile::SampleCallStackFrame::Kind::JSFunction,
          0,
          "(program)"});
  auto* idleNode = new ProfileTreeNode(
      ++nodeCount,
      ProfileTreeNode::CodeType::Other,
      rootNode,
      RuntimeSamplingProfile::SampleCallStackFrame{
          RuntimeSamplingProfile::SampleCallStackFrame::Kind::JSFunction,
          0,
          "(idle)"});

  rootNode->addChild(programNode);
  rootNode->addChild(idleNode);

  // Ideally, we should use a timestamp from Runtime Sampling Profiler.
  // We currently use tracingStartTime, which is defined in TracingAgent.
  uint64_t previousSampleTimestamp = tracingStartUnixTimestamp;
  // There could be any number of new nodes in this chunk. Empty if all nodes
  // are already emitted in previous chunks.
  std::vector<ProfileTreeNode*> nodesInThisChunk;
  nodesInThisChunk.push_back(rootNode);
  nodesInThisChunk.push_back(programNode);
  nodesInThisChunk.push_back(idleNode);

  std::vector<uint32_t> samplesInThisChunk;
  samplesInThisChunk.reserve(profileChunkSize);
  std::vector<long long> timeDeltasInThisChunk;
  timeDeltasInThisChunk.reserve(profileChunkSize);

  RuntimeSamplingProfile::SampleCallStackFrame garbageCollectorCallFrame =
      RuntimeSamplingProfile::SampleCallStackFrame{
          RuntimeSamplingProfile::SampleCallStackFrame::Kind::GarbageCollector,
          0,
          "(garbage collector)"};
  uint64_t chunkTimestamp = tracingStartUnixTimestamp;
  for (const RuntimeSamplingProfile::Sample& sample : runtimeSamples) {
    uint64_t sampleThreadId = sample.getThreadId();
    // If next sample was recorded on a different thread, emit the current chunk
    // and continue.
    if (chunkThreadId != sampleThreadId) {
      emitSingleProfileChunk(
          performanceTracer,
          profileId,
          chunkThreadId,
          chunkTimestamp,
          nodesInThisChunk,
          samplesInThisChunk,
          timeDeltasInThisChunk);

      nodesInThisChunk.clear();
      samplesInThisChunk.clear();
      timeDeltasInThisChunk.clear();
    }

    chunkThreadId = sampleThreadId;
    std::vector<RuntimeSamplingProfile::SampleCallStackFrame> callStack =
        sample.getCallStack();
    uint64_t sampleTimestamp = sample.getTimestamp();
    if (samplesInThisChunk.empty()) {
      // New chunk. Reset the timestamp.
      chunkTimestamp = sampleTimestamp;
    }

    long long timeDelta = sampleTimestamp - previousSampleTimestamp;
    timeDeltasInThisChunk.push_back(timeDelta);
    previousSampleTimestamp = sampleTimestamp;

    ProfileTreeNode* previousNode = callStack.empty() ? idleNode : rootNode;
    for (auto it = callStack.rbegin(); it != callStack.rend(); ++it) {
      auto callFrame = *it;
      bool isGarbageCollectorFrame = callFrame.getKind() ==
          RuntimeSamplingProfile::SampleCallStackFrame::Kind::GarbageCollector;
      // We don't need real garbage collector call frame, we change it to
      // what Chrome DevTools expects.
      auto* currentNode = new ProfileTreeNode(
          nodeCount + 1,
          isGarbageCollectorFrame ? ProfileTreeNode::CodeType::Other
                                  : ProfileTreeNode::CodeType::JavaScript,
          previousNode,
          isGarbageCollectorFrame ? garbageCollectorCallFrame : callFrame);

      ProfileTreeNode* alreadyExistingNode =
          previousNode->addChild(currentNode);
      if (alreadyExistingNode != nullptr) {
        previousNode = alreadyExistingNode;
      } else {
        nodesInThisChunk.push_back(currentNode);
        ++nodeCount;

        previousNode = currentNode;
      }
    }
    samplesInThisChunk.push_back(previousNode->getId());

    if (samplesInThisChunk.size() == profileChunkSize) {
      emitSingleProfileChunk(
          performanceTracer,
          profileId,
          chunkThreadId,
          chunkTimestamp,
          nodesInThisChunk,
          samplesInThisChunk,
          timeDeltasInThisChunk);

      nodesInThisChunk.clear();
      samplesInThisChunk.clear();
      timeDeltasInThisChunk.clear();
    }
  }

  if (!samplesInThisChunk.empty()) {
    emitSingleProfileChunk(
        performanceTracer,
        profileId,
        chunkThreadId,
        chunkTimestamp,
        nodesInThisChunk,
        samplesInThisChunk,
        timeDeltasInThisChunk);
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
  }
}

} // namespace facebook::react::jsinspector_modern::tracing
