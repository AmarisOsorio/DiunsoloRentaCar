/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include "PerformanceTracer.h"
<<<<<<< HEAD
#include "Timing.h"

#include <oscompat/OSCompat.h>
#include <react/timing/primitives.h>

#include <folly/json.h>

#include <array>
#include <mutex>

namespace facebook::react::jsinspector_modern::tracing {
=======

#include <oscompat/OSCompat.h>

#include <folly/json.h>

#include <mutex>

namespace facebook::react::jsinspector_modern {

namespace {

uint64_t getUnixTimestampOfNow() {
  return std::chrono::duration_cast<std::chrono::microseconds>(
             std::chrono::steady_clock::now().time_since_epoch())
      .count();
}

} // namespace
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767

PerformanceTracer& PerformanceTracer::getInstance() {
  static PerformanceTracer tracer;
  return tracer;
}

PerformanceTracer::PerformanceTracer()
    : processId_(oscompat::getCurrentProcessId()) {}

bool PerformanceTracer::startTracing() {
  {
    std::lock_guard lock(mutex_);
<<<<<<< HEAD
    if (tracingAtomic_) {
      return false;
    }
    tracingAtomic_ = true;
=======
    if (tracing_) {
      return false;
    }

    tracing_ = true;
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
  }

  reportProcess(processId_, "React Native");

  {
    std::lock_guard lock(mutex_);
<<<<<<< HEAD
    if (!tracingAtomic_) {
      return false;
    }
    buffer_.emplace_back(TraceEvent{
        .name = "TracingStartedInPage",
        .cat = "disabled-by-default-devtools.timeline",
        .ph = 'I',
        .ts = HighResTimeStamp::now(),
=======
    buffer_.push_back(TraceEvent{
        .name = "TracingStartedInPage",
        .cat = "disabled-by-default-devtools.timeline",
        .ph = 'I',
        .ts = getUnixTimestampOfNow(),
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
        .pid = processId_,
        .tid = oscompat::getCurrentThreadId(),
        .args = folly::dynamic::object("data", folly::dynamic::object()),
    });
<<<<<<< HEAD
  }

  return true;
=======

    return true;
  }
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
}

bool PerformanceTracer::stopTracing() {
  std::lock_guard lock(mutex_);
<<<<<<< HEAD
  if (!tracingAtomic_) {
    return false;
  }
  tracingAtomic_ = false;
=======
  if (!tracing_) {
    return false;
  }
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767

  // This is synthetic Trace Event, which should not be represented on a
  // timeline. CDT is not using Profile or ProfileChunk events for determining
  // trace timeline window, this is why trace that only contains JavaScript
  // samples will be displayed as empty. We use this event to avoid that.
  // This could happen for non-bridgeless apps, where Performance interface is
  // not supported and no spec-compliant Event Loop implementation.
<<<<<<< HEAD
  buffer_.emplace_back(TraceEvent{
      .name = "ReactNative-TracingStopped",
      .cat = "disabled-by-default-devtools.timeline",
      .ph = 'I',
      .ts = HighResTimeStamp::now(),
=======
  buffer_.push_back(TraceEvent{
      .name = "ReactNative-TracingStopped",
      .cat = "disabled-by-default-devtools.timeline",
      .ph = 'I',
      .ts = getUnixTimestampOfNow(),
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
      .pid = processId_,
      .tid = oscompat::getCurrentThreadId(),
  });

  performanceMeasureCount_ = 0;
<<<<<<< HEAD
=======
  profileCount_ = 0;
  tracing_ = false;
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
  return true;
}

void PerformanceTracer::collectEvents(
    const std::function<void(const folly::dynamic& eventsChunk)>&
        resultCallback,
    uint16_t chunkSize) {
<<<<<<< HEAD
  std::vector<TraceEvent> localBuffer;
  {
    std::lock_guard lock(mutex_);
    buffer_.swap(localBuffer);
  }

  if (localBuffer.empty()) {
    return;
  }

  auto serializedTraceEvents = folly::dynamic::array();
  for (auto&& event : localBuffer) {
    // Emit trace events
    serializedTraceEvents.push_back(serializeTraceEvent(std::move(event)));

    if (serializedTraceEvents.size() == chunkSize) {
      resultCallback(serializedTraceEvents);
      serializedTraceEvents = folly::dynamic::array();
    }
  }
  if (!serializedTraceEvents.empty()) {
    resultCallback(serializedTraceEvents);
  }
=======
  std::lock_guard lock(mutex_);

  if (buffer_.empty()) {
    return;
  }

  auto traceEvents = folly::dynamic::array();
  for (auto event : buffer_) {
    // Emit trace events
    traceEvents.push_back(serializeTraceEvent(event));

    if (traceEvents.size() == chunkSize) {
      resultCallback(traceEvents);
      traceEvents = folly::dynamic::array();
    }
  }
  if (!traceEvents.empty()) {
    resultCallback(traceEvents);
  }

  buffer_.clear();
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
}

void PerformanceTracer::reportMark(
    const std::string_view& name,
<<<<<<< HEAD
    HighResTimeStamp start) {
  if (!tracingAtomic_) {
=======
    uint64_t start) {
  if (!tracing_) {
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
    return;
  }

  std::lock_guard<std::mutex> lock(mutex_);
<<<<<<< HEAD
  if (!tracingAtomic_) {
    return;
  }

  buffer_.emplace_back(TraceEvent{
=======
  if (!tracing_) {
    return;
  }

  buffer_.push_back(TraceEvent{
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
      .name = std::string(name),
      .cat = "blink.user_timing",
      .ph = 'I',
      .ts = start,
      .pid = processId_,
      .tid = oscompat::getCurrentThreadId(),
  });
}

void PerformanceTracer::reportMeasure(
    const std::string_view& name,
<<<<<<< HEAD
    HighResTimeStamp start,
    HighResDuration duration,
    const std::optional<DevToolsTrackEntryPayload>& trackMetadata) {
  if (!tracingAtomic_) {
=======
    uint64_t start,
    uint64_t duration,
    const std::optional<DevToolsTrackEntryPayload>& trackMetadata) {
  if (!tracing_) {
    return;
  }

  std::lock_guard<std::mutex> lock(mutex_);
  if (!tracing_) {
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
    return;
  }

  folly::dynamic beginEventArgs = folly::dynamic::object();
  if (trackMetadata.has_value()) {
    folly::dynamic devtoolsObject = folly::dynamic::object(
        "devtools",
        folly::dynamic::object("track", trackMetadata.value().track));
    beginEventArgs =
        folly::dynamic::object("detail", folly::toJson(devtoolsObject));
  }

<<<<<<< HEAD
  auto currentThreadId = oscompat::getCurrentThreadId();

  std::lock_guard<std::mutex> lock(mutex_);
  if (!tracingAtomic_) {
    return;
  }
  auto eventId = ++performanceMeasureCount_;

  buffer_.emplace_back(TraceEvent{
      .id = eventId,
=======
  ++performanceMeasureCount_;
  auto currentThreadId = oscompat::getCurrentThreadId();
  buffer_.push_back(TraceEvent{
      .id = performanceMeasureCount_,
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
      .name = std::string(name),
      .cat = "blink.user_timing",
      .ph = 'b',
      .ts = start,
      .pid = processId_,
      .tid = currentThreadId,
      .args = beginEventArgs,
  });
<<<<<<< HEAD
  buffer_.emplace_back(TraceEvent{
      .id = eventId,
=======
  buffer_.push_back(TraceEvent{
      .id = performanceMeasureCount_,
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
      .name = std::string(name),
      .cat = "blink.user_timing",
      .ph = 'e',
      .ts = start + duration,
      .pid = processId_,
      .tid = currentThreadId,
  });
}

<<<<<<< HEAD
void PerformanceTracer::reportTimeStamp(
    std::string name,
    std::optional<ConsoleTimeStampEntry> start,
    std::optional<ConsoleTimeStampEntry> end,
    std::optional<std::string> trackName,
    std::optional<std::string> trackGroup,
    std::optional<ConsoleTimeStampColor> color) {
  if (!tracingAtomic_) {
    return;
  }

  // `name` takes precedence over `message` in Chrome DevTools Frontend, no need
  // to record both.
  folly::dynamic data = folly::dynamic::object("name", std::move(name));
  if (start) {
    if (std::holds_alternative<HighResTimeStamp>(*start)) {
      data["start"] = highResTimeStampToTracingClockTimeStamp(
          std::get<HighResTimeStamp>(*start));
    } else {
      data["start"] = std::move(std::get<std::string>(*start));
    }
  }
  if (end) {
    if (std::holds_alternative<HighResTimeStamp>(*end)) {
      data["end"] = highResTimeStampToTracingClockTimeStamp(
          std::get<HighResTimeStamp>(*end));
    } else {
      data["end"] = std::move(std::get<std::string>(*end));
    }
  }
  if (trackName) {
    data["track"] = std::move(*trackName);
  }
  if (trackGroup) {
    data["trackGroup"] = std::move(*trackGroup);
  }
  if (color) {
    data["color"] = consoleTimeStampColorToString(*color);
  }

  std::lock_guard<std::mutex> lock(mutex_);
  if (!tracingAtomic_) {
    return;
  }
  buffer_.emplace_back(TraceEvent{
      .name = "TimeStamp",
      .cat = "devtools.timeline",
      .ph = 'I',
      .ts = HighResTimeStamp::now(),
      .pid = processId_,
      .tid = oscompat::getCurrentThreadId(),
      .args = folly::dynamic::object("data", std::move(data)),
  });
}

void PerformanceTracer::reportProcess(uint64_t id, const std::string& name) {
  if (!tracingAtomic_) {
=======
void PerformanceTracer::reportProcess(uint64_t id, const std::string& name) {
  if (!tracing_) {
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
    return;
  }

  std::lock_guard<std::mutex> lock(mutex_);
<<<<<<< HEAD
  if (!tracingAtomic_) {
    return;
  }

  buffer_.emplace_back(TraceEvent{
      .name = "process_name",
      .cat = "__metadata",
      .ph = 'M',
      .ts = TRACING_TIME_ORIGIN,
=======
  if (!tracing_) {
    return;
  }

  buffer_.push_back(TraceEvent{
      .name = "process_name",
      .cat = "__metadata",
      .ph = 'M',
      .ts = 0,
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
      .pid = id,
      .tid = 0,
      .args = folly::dynamic::object("name", name),
  });
}

void PerformanceTracer::reportJavaScriptThread() {
  reportThread(oscompat::getCurrentThreadId(), "JavaScript");
}

void PerformanceTracer::reportThread(uint64_t id, const std::string& name) {
<<<<<<< HEAD
  if (!tracingAtomic_) {
=======
  if (!tracing_) {
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
    return;
  }

  std::lock_guard<std::mutex> lock(mutex_);
<<<<<<< HEAD
  if (!tracingAtomic_) {
    return;
  }

  buffer_.emplace_back(TraceEvent{
      .name = "thread_name",
      .cat = "__metadata",
      .ph = 'M',
      .ts = TRACING_TIME_ORIGIN,
=======
  if (!tracing_) {
    return;
  }

  buffer_.push_back(TraceEvent{
      .name = "thread_name",
      .cat = "__metadata",
      .ph = 'M',
      .ts = 0,
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
      .pid = processId_,
      .tid = id,
      .args = folly::dynamic::object("name", name),
  });

  // This is synthetic Trace Event, which should not be represented on a
  // timeline. CDT will filter out threads that only have JavaScript samples and
  // no timeline events or user timings. We use this event to avoid that.
  // This could happen for non-bridgeless apps, where Performance interface is
  // not supported and no spec-compliant Event Loop implementation.
<<<<<<< HEAD
  buffer_.emplace_back(TraceEvent{
      .name = "ReactNative-ThreadRegistered",
      .cat = "disabled-by-default-devtools.timeline",
      .ph = 'I',
      .ts = TRACING_TIME_ORIGIN,
=======
  buffer_.push_back(TraceEvent{
      .name = "ReactNative-ThreadRegistered",
      .cat = "disabled-by-default-devtools.timeline",
      .ph = 'I',
      .ts = 0,
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
      .pid = processId_,
      .tid = id,
  });
}

<<<<<<< HEAD
void PerformanceTracer::reportEventLoopTask(
    HighResTimeStamp start,
    HighResTimeStamp end) {
  if (!tracingAtomic_) {
    return;
  }

  std::lock_guard<std::mutex> lock(mutex_);
  if (!tracingAtomic_) {
    return;
  }

  buffer_.emplace_back(TraceEvent{
=======
uint16_t PerformanceTracer::reportRuntimeProfile(
    uint64_t threadId,
    uint64_t eventUnixTimestamp) {
  std::lock_guard lock(mutex_);
  if (!tracing_) {
    throw std::runtime_error(
        "Runtime Profile should only be reported when Tracing is enabled");
  }

  ++profileCount_;
  // CDT prioritizes event timestamp over startTime metadata field.
  // https://fburl.com/lo764pf4
  buffer_.push_back(TraceEvent{
      .id = profileCount_,
      .name = "Profile",
      .cat = "disabled-by-default-v8.cpu_profiler",
      .ph = 'P',
      .ts = eventUnixTimestamp,
      .pid = processId_,
      .tid = threadId,
      .args = folly::dynamic::object(
          "data", folly ::dynamic::object("startTime", eventUnixTimestamp)),
  });

  return profileCount_;
}

void PerformanceTracer::reportRuntimeProfileChunk(
    uint16_t profileId,
    uint64_t threadId,
    uint64_t eventUnixTimestamp,
    const tracing::TraceEventProfileChunk& traceEventProfileChunk) {
  std::lock_guard lock(mutex_);
  if (!tracing_) {
    return;
  }

  buffer_.push_back(TraceEvent{
      .id = profileId,
      .name = "ProfileChunk",
      .cat = "disabled-by-default-v8.cpu_profiler",
      .ph = 'P',
      .ts = eventUnixTimestamp,
      .pid = processId_,
      .tid = threadId,
      .args =
          folly::dynamic::object("data", traceEventProfileChunk.asDynamic()),
  });
}

void PerformanceTracer::reportEventLoopTask(uint64_t start, uint64_t end) {
  if (!tracing_) {
    return;
  }

  std::lock_guard lock(mutex_);
  if (!tracing_) {
    return;
  }

  buffer_.push_back(TraceEvent{
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
      .name = "RunTask",
      .cat = "disabled-by-default-devtools.timeline",
      .ph = 'X',
      .ts = start,
      .pid = oscompat::getCurrentProcessId(),
      .tid = oscompat::getCurrentThreadId(),
      .dur = end - start,
  });
}

<<<<<<< HEAD
void PerformanceTracer::reportEventLoopMicrotasks(
    HighResTimeStamp start,
    HighResTimeStamp end) {
  if (!tracingAtomic_) {
    return;
  }

  std::lock_guard<std::mutex> lock(mutex_);
  if (!tracingAtomic_) {
    return;
  }

  buffer_.emplace_back(TraceEvent{
      .name = "RunMicrotasks",
      .cat = "v8.execute",
      .ph = 'X',
      .ts = start,
      .pid = oscompat::getCurrentProcessId(),
      .tid = oscompat::getCurrentThreadId(),
      .dur = end - start,
  });
}

folly::dynamic PerformanceTracer::getSerializedRuntimeProfileTraceEvent(
    uint64_t threadId,
    uint16_t profileId,
    HighResTimeStamp profileTimestamp) {
  // CDT prioritizes event timestamp over startTime metadata field.
  // https://fburl.com/lo764pf4
  return serializeTraceEvent(TraceEvent{
      .id = profileId,
      .name = "Profile",
      .cat = "disabled-by-default-v8.cpu_profiler",
      .ph = 'P',
      .ts = profileTimestamp,
      .pid = processId_,
      .tid = threadId,
      .args = folly::dynamic::object(
          "data",
          folly::dynamic::object(
              "startTime",
              highResTimeStampToTracingClockTimeStamp(profileTimestamp))),
  });
}

folly::dynamic PerformanceTracer::getSerializedRuntimeProfileChunkTraceEvent(
    uint16_t profileId,
    uint64_t threadId,
    HighResTimeStamp chunkTimestamp,
    const tracing::TraceEventProfileChunk& traceEventProfileChunk) {
  return serializeTraceEvent(TraceEvent{
      .id = profileId,
      .name = "ProfileChunk",
      .cat = "disabled-by-default-v8.cpu_profiler",
      .ph = 'P',
      .ts = chunkTimestamp,
      .pid = processId_,
      .tid = threadId,
      .args =
          folly::dynamic::object("data", traceEventProfileChunk.toDynamic()),
  });
}

folly::dynamic PerformanceTracer::serializeTraceEvent(
    TraceEvent&& event) const {
  folly::dynamic result = folly::dynamic::object;

  if (event.id.has_value()) {
    std::array<char, 16> buffer{};
    snprintf(buffer.data(), buffer.size(), "0x%x", event.id.value());
    result["id"] = buffer.data();
  }
  result["name"] = std::move(event.name);
  result["cat"] = std::move(event.cat);
  result["ph"] = std::string(1, event.ph);
  result["ts"] = highResTimeStampToTracingClockTimeStamp(event.ts);
  result["pid"] = event.pid;
  result["tid"] = event.tid;
  result["args"] = std::move(event.args);
  if (event.dur.has_value()) {
    result["dur"] = highResDurationToTracingClockDuration(event.dur.value());
=======
folly::dynamic PerformanceTracer::serializeTraceEvent(TraceEvent event) const {
  folly::dynamic result = folly::dynamic::object;

  if (event.id.has_value()) {
    result["id"] = folly::sformat("0x{:X}", event.id.value());
  }
  result["name"] = event.name;
  result["cat"] = event.cat;
  result["ph"] = std::string(1, event.ph);
  result["ts"] = event.ts;
  result["pid"] = event.pid;
  result["tid"] = event.tid;
  result["args"] = event.args;
  if (event.dur.has_value()) {
    result["dur"] = event.dur.value();
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
  }

  return result;
}

<<<<<<< HEAD
} // namespace facebook::react::jsinspector_modern::tracing
=======
} // namespace facebook::react::jsinspector_modern
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
