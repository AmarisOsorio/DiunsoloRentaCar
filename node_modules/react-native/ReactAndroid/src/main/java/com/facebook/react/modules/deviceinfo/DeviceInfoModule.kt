/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

package com.facebook.react.modules.deviceinfo

<<<<<<< HEAD
=======
import android.content.Context
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
import com.facebook.fbreact.specs.NativeDeviceInfoSpec
import com.facebook.react.bridge.LifecycleEventListener
import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.bridge.ReactNoCrashSoftException
import com.facebook.react.bridge.ReactSoftExceptionLogger
import com.facebook.react.bridge.ReadableMap
import com.facebook.react.module.annotations.ReactModule
import com.facebook.react.uimanager.DisplayMetricsHolder.getDisplayMetricsWritableMap
import com.facebook.react.uimanager.DisplayMetricsHolder.initDisplayMetricsIfNotInitialized
<<<<<<< HEAD
import com.facebook.react.views.view.isEdgeToEdgeFeatureFlagOn

/** Module that exposes Android Constants to JS. */
@ReactModule(name = NativeDeviceInfoSpec.NAME)
internal class DeviceInfoModule(reactContext: ReactApplicationContext) :
    NativeDeviceInfoSpec(reactContext), LifecycleEventListener {
  private var fontScale: Float = reactContext.resources.configuration.fontScale
  private var previousDisplayMetrics: ReadableMap? = null

  init {
    initDisplayMetricsIfNotInitialized(reactContext)
    reactContext.addLifecycleEventListener(this)
=======

/** Module that exposes Android Constants to JS. */
@ReactModule(name = NativeDeviceInfoSpec.NAME)
public class DeviceInfoModule : NativeDeviceInfoSpec, LifecycleEventListener {
  private var reactApplicationContext: ReactApplicationContext? = null
  private var fontScale: Float
  private var previousDisplayMetrics: ReadableMap? = null

  public constructor(reactContext: ReactApplicationContext) : super(reactContext) {
    initDisplayMetricsIfNotInitialized(reactContext)
    fontScale = reactContext.resources.configuration.fontScale
    reactContext.addLifecycleEventListener(this)
    reactApplicationContext = reactContext
  }

  public constructor(context: Context) : super(null) {
    reactApplicationContext = null
    initDisplayMetricsIfNotInitialized(context)
    fontScale = context.resources.configuration.fontScale
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
  }

  public override fun getTypedExportedConstants(): Map<String, Any> {
    val displayMetrics = getDisplayMetricsWritableMap(fontScale.toDouble())

    // Cache the initial dimensions for later comparison in emitUpdateDimensionsEvent
    previousDisplayMetrics = displayMetrics.copy()
<<<<<<< HEAD

    return mapOf(
        "Dimensions" to displayMetrics.toHashMap(),
        "isEdgeToEdge" to isEdgeToEdgeFeatureFlagOn,
    )
  }

  override fun onHostResume() {
    val newFontScale = reactApplicationContext.resources?.configuration?.fontScale
=======
    return mapOf("Dimensions" to displayMetrics.toHashMap())
  }

  override fun onHostResume() {
    val newFontScale = reactApplicationContext?.resources?.configuration?.fontScale
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
    if (newFontScale != null && newFontScale != fontScale) {
      fontScale = newFontScale
      emitUpdateDimensionsEvent()
    }
  }

  override fun onHostPause(): Unit = Unit

  override fun onHostDestroy(): Unit = Unit

<<<<<<< HEAD
  fun emitUpdateDimensionsEvent() {
    reactApplicationContext.let { context ->
=======
  public fun emitUpdateDimensionsEvent() {
    reactApplicationContext?.let { context ->
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
      if (context.hasActiveReactInstance()) {
        // Don't emit an event to JS if the dimensions haven't changed
        val displayMetrics = getDisplayMetricsWritableMap(fontScale.toDouble())
        if (previousDisplayMetrics == null) {
          previousDisplayMetrics = displayMetrics.copy()
        } else if (displayMetrics != previousDisplayMetrics) {
          previousDisplayMetrics = displayMetrics.copy()
          context.emitDeviceEvent("didUpdateDimensions", displayMetrics)
        }
      } else {
        ReactSoftExceptionLogger.logSoftException(
            NativeDeviceInfoSpec.NAME,
            ReactNoCrashSoftException(
                "No active CatalystInstance, cannot emitUpdateDimensionsEvent"))
      }
    }
  }

  override fun invalidate() {
    super.invalidate()
<<<<<<< HEAD
    reactApplicationContext.removeLifecycleEventListener(this)
  }

  companion object {
    const val NAME: String = NativeDeviceInfoSpec.NAME
=======
    reactApplicationContext?.removeLifecycleEventListener(this)
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
  }
}
