/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

package com.facebook.react.uimanager.events

import android.os.Handler
import android.view.Choreographer
import com.facebook.react.bridge.LifecycleEventListener
import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.bridge.ReactSoftExceptionLogger
<<<<<<< HEAD
=======
import com.facebook.react.bridge.UIManager
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
import com.facebook.react.bridge.UiThreadUtil
import com.facebook.react.common.annotations.UnstableReactNativeAPI
import com.facebook.react.internal.featureflags.ReactNativeFeatureFlags
import com.facebook.react.modules.core.ReactChoreographer
import com.facebook.react.uimanager.UIManagerHelper
import com.facebook.react.uimanager.common.UIManagerType
import com.facebook.systrace.Systrace
import java.util.concurrent.CopyOnWriteArrayList
import kotlin.concurrent.Volatile

private const val TAG = "FabricEventDispatcher"

/**
 * A singleton class that overrides [EventDispatcher] with no-op methods, to be used by callers that
 * expect an EventDispatcher when the instance doesn't exist.
<<<<<<< HEAD
 *
 * While this class is Fabric-specific, it lives in the uimanager.events package to allow access to
 * Event internals.
 */
internal class FabricEventDispatcher(
    private val reactContext: ReactApplicationContext,
    fabricEventEmitter: RCTModernEventEmitter
) : EventDispatcher, LifecycleEventListener {
  // TODO: Remove EventEmitterImpl indirection when new Fabric is fully rolled out
  private val eventEmitter = EventEmitterImpl(reactContext)
  private val listeners = CopyOnWriteArrayList<EventDispatcherListener>()
  private val postEventDispatchListeners = CopyOnWriteArrayList<BatchEventDispatchedListener>()
  private val currentFrameCallback = ScheduleDispatchFrameCallback()
=======
 */
public open class FabricEventDispatcher(reactContext: ReactApplicationContext) :
    EventDispatcher, LifecycleEventListener {
  private val reactEventEmitter: ReactEventEmitter
  private val reactContext: ReactApplicationContext = reactContext
  private val listeners = CopyOnWriteArrayList<EventDispatcherListener>()
  private val postEventDispatchListeners = CopyOnWriteArrayList<BatchEventDispatchedListener>()
  private val currentFrameCallback: ScheduleDispatchFrameCallback = ScheduleDispatchFrameCallback()
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767

  private var isDispatchScheduled = false
  private val dispatchEventsRunnable = Runnable {
    isDispatchScheduled = false
<<<<<<< HEAD
    Systrace.beginSection(Systrace.TRACE_TAG_REACT, "BatchEventDispatchedListeners")
=======
    Systrace.beginSection(Systrace.TRACE_TAG_REACT_JAVA_BRIDGE, "BatchEventDispatchedListeners")
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
    try {
      for (listener in postEventDispatchListeners) {
        listener.onBatchEventDispatched()
      }
    } finally {
<<<<<<< HEAD
      Systrace.endSection(Systrace.TRACE_TAG_REACT)
=======
      Systrace.endSection(Systrace.TRACE_TAG_REACT_JAVA_BRIDGE)
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
    }
  }

  init {
<<<<<<< HEAD
    reactContext.addLifecycleEventListener(this)
    eventEmitter.registerFabricEventEmitter(fabricEventEmitter)
  }

  override fun dispatchEvent(event: Event<*>) {
    for (listener in listeners) {
      listener.onEventDispatch(event)
    }
    if (event.internal_experimental_isSynchronous()) {
      dispatchSynchronous(event)
    } else {
      event.dispatchModern(eventEmitter)
=======
    this.reactContext.addLifecycleEventListener(this)
    reactEventEmitter = ReactEventEmitter(this.reactContext)
  }

  public override fun dispatchEvent(event: Event<*>) {
    for (listener in listeners) {
      listener.onEventDispatch(event)
    }
    if (event.experimental_isSynchronous()) {
      dispatchSynchronous(event)
    } else {
      event.dispatchModern(reactEventEmitter)
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
    }

    event.dispose()
    scheduleDispatchOfBatchedEvents()
  }

  private fun dispatchSynchronous(event: Event<*>) {
    Systrace.beginSection(
<<<<<<< HEAD
        Systrace.TRACE_TAG_REACT,
        "FabricEventDispatcher.dispatchSynchronous('" + event.getEventName() + "')")
    try {
      val fabricUIManager = UIManagerHelper.getUIManager(reactContext, UIManagerType.FABRIC)
=======
        Systrace.TRACE_TAG_REACT_JAVA_BRIDGE,
        "FabricEventDispatcher.dispatchSynchronous('" + event.eventName + "')")
    try {
      val fabricUIManager: UIManager? =
          UIManagerHelper.getUIManager(reactContext, UIManagerType.FABRIC)
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
      @OptIn(UnstableReactNativeAPI::class)
      if (fabricUIManager is SynchronousEventReceiver) {
        (fabricUIManager as SynchronousEventReceiver).receiveEvent(
            event.surfaceId,
            event.viewTag,
<<<<<<< HEAD
            event.getEventName(),
            event.canCoalesce(),
            event.internal_getEventData(),
            event.internal_getEventCategory(),
=======
            event.eventName,
            event.canCoalesce(),
            event.eventData,
            event.eventCategory,
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
            true)
      } else {
        ReactSoftExceptionLogger.logSoftException(
            TAG,
            IllegalStateException(
                "Fabric UIManager expected to implement SynchronousEventReceiver."))
      }
    } finally {
<<<<<<< HEAD
      Systrace.endSection(Systrace.TRACE_TAG_REACT)
    }
  }

  override fun dispatchAllEvents() {
=======
      Systrace.endSection(Systrace.TRACE_TAG_REACT_JAVA_BRIDGE)
    }
  }

  public override fun dispatchAllEvents() {
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
    scheduleDispatchOfBatchedEvents()
  }

  private fun scheduleDispatchOfBatchedEvents() {
    if (ReactNativeFeatureFlags.useOptimizedEventBatchingOnAndroid()) {
      if (!isDispatchScheduled) {
        isDispatchScheduled = true
        uiThreadHandler.postAtFrontOfQueue(dispatchEventsRunnable)
      }
    } else {
      currentFrameCallback.maybeScheduleDispatchOfBatchedEvents()
    }
  }

  /** Add a listener to this EventDispatcher. */
<<<<<<< HEAD
  override fun addListener(listener: EventDispatcherListener) {
=======
  public override fun addListener(listener: EventDispatcherListener) {
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
    listeners.add(listener)
  }

  /** Remove a listener from this EventDispatcher. */
<<<<<<< HEAD
  override fun removeListener(listener: EventDispatcherListener) {
    listeners.remove(listener)
  }

  override fun addBatchEventDispatchedListener(listener: BatchEventDispatchedListener) {
    postEventDispatchListeners.add(listener)
  }

  override fun removeBatchEventDispatchedListener(listener: BatchEventDispatchedListener) {
    postEventDispatchListeners.remove(listener)
  }

  override fun onHostResume() {
=======
  public override fun removeListener(listener: EventDispatcherListener) {
    listeners.remove(listener)
  }

  public override fun addBatchEventDispatchedListener(listener: BatchEventDispatchedListener) {
    postEventDispatchListeners.add(listener)
  }

  public override fun removeBatchEventDispatchedListener(listener: BatchEventDispatchedListener) {
    postEventDispatchListeners.remove(listener)
  }

  public override fun onHostResume() {
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
    scheduleDispatchOfBatchedEvents()
    if (!ReactNativeFeatureFlags.useOptimizedEventBatchingOnAndroid()) {
      currentFrameCallback.resume()
    }
  }

<<<<<<< HEAD
  override fun onHostPause() {
    cancelDispatchOfBatchedEvents()
  }

  override fun onHostDestroy() {
    cancelDispatchOfBatchedEvents()
  }

  fun invalidate() {
    eventEmitter.registerFabricEventEmitter(null)

    UiThreadUtil.runOnUiThread { cancelDispatchOfBatchedEvents() }
  }

  @Deprecated("Private API, should only be used when the concrete implementation is known.")
  override fun onCatalystInstanceDestroyed() {
    invalidate()
=======
  public override fun onHostPause() {
    cancelDispatchOfBatchedEvents()
  }

  public override fun onHostDestroy() {
    cancelDispatchOfBatchedEvents()
  }

  public override fun onCatalystInstanceDestroyed() {
    UiThreadUtil.runOnUiThread(Runnable { cancelDispatchOfBatchedEvents() })
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
  }

  private fun cancelDispatchOfBatchedEvents() {
    UiThreadUtil.assertOnUiThread()
    if (ReactNativeFeatureFlags.useOptimizedEventBatchingOnAndroid()) {
      isDispatchScheduled = false
      uiThreadHandler.removeCallbacks(dispatchEventsRunnable)
    } else {
      currentFrameCallback.stop()
    }
  }

<<<<<<< HEAD
=======
  @Deprecated("Use the modern version with RCTModernEventEmitter")
  @Suppress("DEPRECATION")
  public override fun registerEventEmitter(
      @UIManagerType uiManagerType: Int,
      eventEmitter: RCTEventEmitter
  ) {
    reactEventEmitter.register(uiManagerType, eventEmitter)
  }

  public override fun registerEventEmitter(
      @UIManagerType uiManagerType: Int,
      eventEmitter: RCTModernEventEmitter
  ) {
    reactEventEmitter.register(uiManagerType, eventEmitter)
  }

  public override fun unregisterEventEmitter(@UIManagerType uiManagerType: Int) {
    reactEventEmitter.unregister(uiManagerType)
  }

>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
  private inner class ScheduleDispatchFrameCallback : Choreographer.FrameCallback {
    @Volatile private var isFrameCallbackDispatchScheduled = false
    private var shouldStop = false

    override fun doFrame(frameTimeNanos: Long) {
      UiThreadUtil.assertOnUiThread()

      if (shouldStop) {
        isFrameCallbackDispatchScheduled = false
      } else {
        dispatchBatchedEvents()
      }

<<<<<<< HEAD
      Systrace.beginSection(Systrace.TRACE_TAG_REACT, "BatchEventDispatchedListeners")
=======
      Systrace.beginSection(Systrace.TRACE_TAG_REACT_JAVA_BRIDGE, "BatchEventDispatchedListeners")
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
      try {
        for (listener in postEventDispatchListeners) {
          listener.onBatchEventDispatched()
        }
      } finally {
<<<<<<< HEAD
        Systrace.endSection(Systrace.TRACE_TAG_REACT)
=======
        Systrace.endSection(Systrace.TRACE_TAG_REACT_JAVA_BRIDGE)
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
      }
    }

    fun stop() {
      shouldStop = true
    }

    fun resume() {
      shouldStop = false
    }

    fun maybeDispatchBatchedEvents() {
      if (!isFrameCallbackDispatchScheduled) {
        isFrameCallbackDispatchScheduled = true
        dispatchBatchedEvents()
      }
    }

    private fun dispatchBatchedEvents() {
      ReactChoreographer.getInstance()
          .postFrameCallback(ReactChoreographer.CallbackType.TIMERS_EVENTS, currentFrameCallback)
    }

    fun maybeScheduleDispatchOfBatchedEvents() {
      if (isFrameCallbackDispatchScheduled) {
        return
      }

      // We should only hit this slow path when we receive events while the host activity is paused.
      if (reactContext.isOnUiQueueThread()) {
        maybeDispatchBatchedEvents()
      } else {
<<<<<<< HEAD
        reactContext.runOnUiQueueThread { maybeDispatchBatchedEvents() }
=======
        reactContext.runOnUiQueueThread(Runnable { maybeDispatchBatchedEvents() })
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
      }
    }
  }

  private companion object {
    private val uiThreadHandler: Handler = UiThreadUtil.getUiThreadHandler()
  }
}
