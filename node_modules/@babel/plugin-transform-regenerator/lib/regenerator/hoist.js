"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hoist = hoist;
<<<<<<< HEAD
var _core = require("@babel/core");
function hoist(funPath) {
  _core.types.assertFunction(funPath.node);
  const vars = {
    __proto__: null
  };
=======
var util = require("./util.js");
const hasOwn = Object.prototype.hasOwnProperty;
function hoist(funPath) {
  const t = util.getTypes();
  t.assertFunction(funPath.node);
  const vars = {};
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
  function varDeclToExpr({
    node: vdec,
    scope
  }, includeIdentifiers) {
<<<<<<< HEAD
    _core.types.assertVariableDeclaration(vdec);
    const exprs = [];
    vdec.declarations.forEach(function (dec) {
      vars[dec.id.name] = _core.types.identifier(dec.id.name);
      scope.removeBinding(dec.id.name);
      if (dec.init) {
        exprs.push(_core.types.assignmentExpression("=", dec.id, dec.init));
=======
    t.assertVariableDeclaration(vdec);
    const exprs = [];
    vdec.declarations.forEach(function (dec) {
      vars[dec.id.name] = t.identifier(dec.id.name);
      scope.removeBinding(dec.id.name);
      if (dec.init) {
        exprs.push(t.assignmentExpression("=", dec.id, dec.init));
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
      } else if (includeIdentifiers) {
        exprs.push(dec.id);
      }
    });
    if (exprs.length === 0) return null;
    if (exprs.length === 1) return exprs[0];
<<<<<<< HEAD
    return _core.types.sequenceExpression(exprs);
=======
    return t.sequenceExpression(exprs);
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
  }
  funPath.get("body").traverse({
    VariableDeclaration: {
      exit: function (path) {
        const expr = varDeclToExpr(path, false);
        if (expr === null) {
          path.remove();
        } else {
<<<<<<< HEAD
          path.replaceWith(_core.types.expressionStatement(expr));
=======
          util.replaceWithOrRemove(path, t.expressionStatement(expr));
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
        }
        path.skip();
      }
    },
    ForStatement: function (path) {
      const init = path.get("init");
      if (init.isVariableDeclaration()) {
<<<<<<< HEAD
        const expr = varDeclToExpr(init, false);
        if (expr) {
          init.replaceWith(expr);
        } else {
          init.remove();
        }
=======
        util.replaceWithOrRemove(init, varDeclToExpr(init, false));
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
      }
    },
    ForXStatement: function (path) {
      const left = path.get("left");
      if (left.isVariableDeclaration()) {
<<<<<<< HEAD
        left.replaceWith(varDeclToExpr(left, true));
=======
        util.replaceWithOrRemove(left, varDeclToExpr(left, true));
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
      }
    },
    FunctionDeclaration: function (path) {
      const node = path.node;
      vars[node.id.name] = node.id;
<<<<<<< HEAD
      const assignment = _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(node.id), _core.types.functionExpression(path.scope.generateUidIdentifierBasedOnNode(node), node.params, node.body, node.generator, node.async)));
=======
      const assignment = t.expressionStatement(t.assignmentExpression("=", t.clone(node.id), t.functionExpression(path.scope.generateUidIdentifierBasedOnNode(node), node.params, node.body, node.generator, node.expression)));
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
      if (path.parentPath.isBlockStatement()) {
        path.parentPath.unshiftContainer("body", assignment);
        path.remove();
      } else {
<<<<<<< HEAD
        path.replaceWith(assignment);
=======
        util.replaceWithOrRemove(path, assignment);
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
      }
      path.scope.removeBinding(node.id.name);
      path.skip();
    },
    FunctionExpression: function (path) {
      path.skip();
    },
    ArrowFunctionExpression: function (path) {
      path.skip();
    }
  });
<<<<<<< HEAD
  const paramNames = {
    __proto__: null
  };
  funPath.get("params").forEach(function (paramPath) {
    const param = paramPath.node;
    if (_core.types.isIdentifier(param)) {
=======
  const paramNames = {};
  funPath.get("params").forEach(function (paramPath) {
    const param = paramPath.node;
    if (t.isIdentifier(param)) {
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
      paramNames[param.name] = param;
    } else {}
  });
  const declarations = [];
  Object.keys(vars).forEach(function (name) {
<<<<<<< HEAD
    if (!hasOwnProperty.call(paramNames, name)) {
      declarations.push(_core.types.variableDeclarator(vars[name], null));
=======
    if (!hasOwn.call(paramNames, name)) {
      declarations.push(t.variableDeclarator(vars[name], null));
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
    }
  });
  return declarations;
}

//# sourceMappingURL=hoist.js.map
