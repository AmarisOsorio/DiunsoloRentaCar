package expo.modules.kotlin.types

import com.facebook.react.bridge.Dynamic
import expo.modules.kotlin.AppContext
import expo.modules.kotlin.exception.NullArgumentException
import expo.modules.kotlin.exception.UnsupportedClass
import expo.modules.kotlin.jni.CppType
import expo.modules.kotlin.jni.ExpectedType

/**
 * Basic type converter. It has to handle two different inputs - [Dynamic] and [Any].
 * The first one is used in the bridge implementation. The second one is used in the JSI.
 */
<<<<<<< HEAD
interface TypeConverter<Type : Any> {
  /**
   * Tries to convert from [Any]? (can be also [Dynamic]) to the desired type.
   */
  fun convert(value: Any?, context: AppContext? = null, forceConversion: Boolean = false): Type?
=======
abstract class TypeConverter<Type : Any> {
  /**
   * Tries to convert from [Any]? (can be also [Dynamic]) to the desired type.
   */
  abstract fun convert(value: Any?, context: AppContext? = null): Type?
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767

  /**
   * Returns a list of [ExpectedType] types that can be converted to the desired type.
   * Sometimes we have a choice between multiple representations of the same value.
   * For instance js object can be pass as [Map] or [expo.modules.kotlin.jni.JavaScriptObject].
   * This value tells us which one we should choose.
   */
<<<<<<< HEAD
  fun getCppRequiredTypes(): ExpectedType = ExpectedType(CppType.ANY)
=======
  open fun getCppRequiredTypes(): ExpectedType = ExpectedType(CppType.ANY)
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767

  /**
   * Checks if the current converter is a trivial one.
   * In that context, a trivial converter indicates a converter that in JSI implementation does nothing.
   * It should be true for most classes.
   */
<<<<<<< HEAD
  fun isTrivial(): Boolean = true
}

abstract class NonNullableTypeConverter<Type : Any>() : TypeConverter<Type> {
  override fun convert(value: Any?, context: AppContext?, forceConversion: Boolean): Type {
    return convertNonNullable(value ?: throw NullArgumentException(), context, forceConversion)
  }

  abstract fun convertNonNullable(value: Any, context: AppContext?, forceConversion: Boolean): Type
=======
  open fun isTrivial(): Boolean = true
}

abstract class NullAwareTypeConverter<Type : Any>(
  /**
   * Whether `null` can be assigned to the desired type.
   */
  private val isOptional: Boolean
) : TypeConverter<Type>() {
  override fun convert(value: Any?, context: AppContext?): Type? {
    if (value == null || value is Dynamic && value.isNull) {
      if (isOptional) {
        return null
      }
      throw NullArgumentException()
    }
    return convertNonOptional(value, context)
  }

  /**
   * Tries to convert from [Any] to the desired type.
   * We know in that place that we're not dealing with `null`.
   */
  abstract fun convertNonOptional(value: Any, context: AppContext?): Type
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
}

/**
 * A helper class to make a clear separation between [Any] and [Dynamic].
 * Right it is used as a default base class for all converters, but this will change when we
 * stop using the bridge to pass data between JS and Kotlin.
 */
<<<<<<< HEAD
abstract class DynamicAwareTypeConverters<T : Any>() : NonNullableTypeConverter<T>() {
  override fun convertNonNullable(value: Any, context: AppContext?, forceConversion: Boolean): T =
    if (value is Dynamic) {
      convertFromDynamic(value, context, forceConversion)
    } else {
      convertFromAny(value, context, forceConversion)
    }

  abstract fun convertFromDynamic(value: Dynamic, context: AppContext?, forceConversion: Boolean): T
  abstract fun convertFromAny(value: Any, context: AppContext?, forceConversion: Boolean): T
}

inline fun <reified T : Any> createTrivialTypeConverter(
  cppRequireType: ExpectedType,
  crossinline dynamicFallback: (Dynamic) -> T = { throw UnsupportedClass(T::class) }
): TypeConverter<T> {
  return object : DynamicAwareTypeConverters<T>() {
    override fun convertFromDynamic(value: Dynamic, context: AppContext?, forceConversion: Boolean): T {
      return dynamicFallback(value)
    }

    override fun convertFromAny(value: Any, context: AppContext?, forceConversion: Boolean): T {
=======
abstract class DynamicAwareTypeConverters<T : Any>(isOptional: Boolean) : NullAwareTypeConverter<T>(isOptional) {
  override fun convertNonOptional(value: Any, context: AppContext?): T =
    if (value is Dynamic) {
      convertFromDynamic(value, context)
    } else {
      convertFromAny(value, context)
    }

  abstract fun convertFromDynamic(value: Dynamic, context: AppContext?): T
  abstract fun convertFromAny(value: Any, context: AppContext?): T
}

inline fun <reified T : Any> createTrivialTypeConverter(
  isOptional: Boolean,
  cppRequireType: ExpectedType,
  crossinline dynamicFallback: (Dynamic) -> T = { throw UnsupportedClass(T::class) }
): TypeConverter<T> {
  return object : DynamicAwareTypeConverters<T>(isOptional) {
    override fun convertFromDynamic(value: Dynamic, context: AppContext?): T {
      return dynamicFallback(value)
    }

    override fun convertFromAny(value: Any, context: AppContext?): T {
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
      return value as T
    }

    override fun getCppRequiredTypes(): ExpectedType = cppRequireType
  }
}
