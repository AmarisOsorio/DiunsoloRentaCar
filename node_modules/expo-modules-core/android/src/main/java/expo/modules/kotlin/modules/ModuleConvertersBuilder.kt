@file:Suppress("FunctionName")

package expo.modules.kotlin.modules

import expo.modules.kotlin.exception.MissingTypeConverter
<<<<<<< HEAD
import expo.modules.kotlin.types.NullableTypeConverter
=======
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
import expo.modules.kotlin.types.TypeConverter
import expo.modules.kotlin.types.TypeConverterComponent
import expo.modules.kotlin.types.TypeConverterProvider
import expo.modules.kotlin.types.lazyTypeOf
import kotlin.reflect.KClass
import kotlin.reflect.KType

class ModuleConvertersBuilder {
  @PublishedApi
  internal var convertersComponent = mutableListOf<TypeConverterComponent<*>>()

<<<<<<< HEAD
  inline fun <reified T : Any> TypeConverter(classifier: KClass<T> = T::class): TypeConverterComponent<T> {
    val converterComponent = TypeConverterComponent<T>(lazyTypeOf<T>())
=======
  inline fun <reified T : Any> TypeConverter(classifier: KClass<T>): TypeConverterComponent<T> {
    val converterComponent = TypeConverterComponent<T>(lazyTypeOf<T>(), lazyTypeOf<(T?)?>())
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
    convertersComponent.add(converterComponent)
    return converterComponent
  }

  inline fun <reified T : Any, reified P0 : Any> TypeConverter(
<<<<<<< HEAD
    classifier: KClass<T> = T::class,
=======
    classifier: KClass<T>,
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
    crossinline body: (p0: P0) -> T
  ): TypeConverterComponent<T> {
    return TypeConverter<T>(classifier).apply {
      from<P0> { value ->
        body(value)
      }
    }
  }

  fun buildTypeConverterProvider(): TypeConverterProvider {
<<<<<<< HEAD
    val converters = convertersComponent
      .mapNotNull { it.build() }

    return object : TypeConverterProvider {
      override fun obtainTypeConverter(type: KType): TypeConverter<*> {
        val nonNullableTypeConverter = findNonNullableTypeConverter(type)
          ?: throw MissingTypeConverter(type)

        if (type.isMarkedNullable) {
          return NullableTypeConverter(nonNullableTypeConverter)
        }
        return nonNullableTypeConverter
      }

      private fun findNonNullableTypeConverter(type: KType): TypeConverter<*>? {
        return converters.find { (converterType, _) ->
          converterType.classifier == type.classifier && converterType.arguments == type.arguments
        }?.second
=======
    val converterMap = convertersComponent
      .map { it.build() }
      .flatten()
      .toMap()
    return object : TypeConverterProvider {
      override fun obtainTypeConverter(type: KType): TypeConverter<*> {
        val typeConverter = converterMap[type]
        if (typeConverter != null) {
          return typeConverter
        } else {
          throw MissingTypeConverter(type)
        }
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
      }
    }
  }
}
