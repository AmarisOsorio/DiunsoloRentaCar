package expo.modules.kotlin.types

import com.facebook.react.bridge.Dynamic
import com.facebook.react.bridge.ReadableArray
import com.facebook.react.bridge.ReadableType
import expo.modules.kotlin.AppContext
import expo.modules.kotlin.exception.CollectionElementCastException
<<<<<<< HEAD
import expo.modules.kotlin.exception.DynamicCastException
=======
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
import expo.modules.kotlin.exception.exceptionDecorator
import expo.modules.kotlin.jni.ExpectedType
import expo.modules.kotlin.recycle
import kotlin.reflect.KType

class ListTypeConverter(
  converterProvider: TypeConverterProvider,
  private val listType: KType
<<<<<<< HEAD
) : DynamicAwareTypeConverters<List<*>>() {
=======
) : DynamicAwareTypeConverters<List<*>>(listType.isMarkedNullable) {
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
  private val elementConverter = converterProvider.obtainTypeConverter(
    requireNotNull(listType.arguments.first().type) {
      "The list type should contain the type of elements."
    }
  )

<<<<<<< HEAD
  override fun convertFromDynamic(value: Dynamic, context: AppContext?, forceConversion: Boolean): List<*> {
=======
  override fun convertFromDynamic(value: Dynamic, context: AppContext?): List<*> {
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
    if (value.type != ReadableType.Array) {
      return listOf(
        exceptionDecorator({ cause ->
          CollectionElementCastException(
            listType,
            listType.arguments.first().type!!,
            value::class,
            cause
          )
        }) {
<<<<<<< HEAD
          elementConverter.convert(value, context, forceConversion)
=======
          elementConverter.convert(value, context)
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
        }
      )
    }

<<<<<<< HEAD
    val jsArray = value.asArray() ?: throw DynamicCastException(ReadableArray::class)
    return convertFromReadableArray(jsArray, context, forceConversion)
  }

  override fun convertFromAny(value: Any, context: AppContext?, forceConversion: Boolean): List<*> {
    return if (elementConverter.isTrivial() && !forceConversion) {
=======
    val jsArray = value.asArray()
    return convertFromReadableArray(jsArray, context)
  }

  override fun convertFromAny(value: Any, context: AppContext?): List<*> {
    return if (elementConverter.isTrivial()) {
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
      value as List<*>
    } else {
      (value as List<*>).map {
        exceptionDecorator({ cause ->
          CollectionElementCastException(
            listType,
            listType.arguments.first().type!!,
            it!!::class,
            cause
          )
        }) {
<<<<<<< HEAD
          elementConverter.convert(it, context, forceConversion)
=======
          elementConverter.convert(it, context)
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
        }
      }
    }
  }

<<<<<<< HEAD
  private fun convertFromReadableArray(jsArray: ReadableArray, context: AppContext?, forceConversion: Boolean): List<*> {
=======
  private fun convertFromReadableArray(jsArray: ReadableArray, context: AppContext?): List<*> {
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
    return List(jsArray.size()) { index ->
      jsArray.getDynamic(index).recycle {
        exceptionDecorator({ cause ->
          CollectionElementCastException(
            listType,
            listType.arguments.first().type!!,
            type,
            cause
          )
        }) {
<<<<<<< HEAD
          elementConverter.convert(this, context, forceConversion)
=======
          elementConverter.convert(this, context)
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
        }
      }
    }
  }

  override fun getCppRequiredTypes(): ExpectedType {
    return ExpectedType.forList(elementConverter.getCppRequiredTypes())
  }

  override fun isTrivial() = elementConverter.isTrivial()
}
