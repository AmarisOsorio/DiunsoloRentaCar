"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.expoInlineEnvVars = expoInlineEnvVars;
<<<<<<< HEAD
const common_1 = require("./common");
const debug = require('debug')('expo:babel:env-vars');
function expoInlineEnvVars(api) {
    const { types: t } = api;
    const isProduction = api.caller(common_1.getIsProd);
    function isFirstInAssign(path) {
        return t.isAssignmentExpression(path.parent) && path.parent.left === path.node;
=======
const core_1 = require("@babel/core");
const common_1 = require("./common");
const debug = require('debug')('expo:babel:env-vars');
function expoInlineEnvVars(api) {
    const isProduction = api.caller(common_1.getIsProd);
    function isFirstInAssign(path) {
        return core_1.types.isAssignmentExpression(path.parent) && path.parent.left === path.node;
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
    }
    let addEnvImport;
    const publicEnvVars = new Set();
    return {
        name: 'expo-inline-or-reference-env-vars',
        pre(file) {
<<<<<<< HEAD
            const addNamedImportOnce = (0, common_1.createAddNamedImportOnce)(t);
=======
            const addNamedImportOnce = (0, common_1.createAddNamedImportOnce)(core_1.types);
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
            addEnvImport = () => {
                return addNamedImportOnce(file.path, 'env', 'expo/virtual/env');
            };
        },
        visitor: {
            MemberExpression(path, state) {
                const filename = state.filename;
                if (path.get('object').matchesPattern('process.env')) {
<<<<<<< HEAD
                    const key = path.toComputedKey();
                    if (t.isStringLiteral(key) &&
=======
                    // @ts-expect-error
                    const key = path.toComputedKey();
                    if (core_1.types.isStringLiteral(key) &&
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
                        !isFirstInAssign(path) &&
                        key.value.startsWith('EXPO_PUBLIC_')) {
                        const envVar = key.value;
                        debug(`${isProduction ? 'Inlining' : 'Referencing'} environment variable in %s: %s`, filename, envVar);
                        publicEnvVars.add(envVar);
                        if (isProduction) {
<<<<<<< HEAD
                            path.replaceWith(t.valueToNode(process.env[envVar]));
                        }
                        else {
                            path.replaceWith(t.memberExpression(addEnvImport(), t.identifier(envVar)));
=======
                            path.replaceWith(core_1.types.valueToNode(process.env[envVar]));
                        }
                        else {
                            path.replaceWith(core_1.types.memberExpression(addEnvImport(), core_1.types.identifier(envVar)));
>>>>>>> 2c830f7d0232ead70791aff6968a0e95ce850767
                        }
                    }
                }
            },
        },
        post(file) {
            assertExpoMetadata(file.metadata);
            file.metadata.publicEnvVars = Array.from(publicEnvVars);
        },
    };
}
function assertExpoMetadata(metadata) {
    if (!metadata || typeof metadata !== 'object') {
        throw new Error('Expected Babel state.file.metadata to be an object');
    }
}
